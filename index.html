<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <link rel="stylesheet" type="text/css" href="css/markdown.css">
    <link rel="stylesheet" type="text/css" href="css/tomorrow.css">
    <link rel="stylesheet" type="text/css" href="css/checkbox.css">
    <script src="jquery/jquery-3.2.1.js"></script>
    <link href="bootstrap-3.3.7-dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="bootstrap-3.3.7-dist/js/bootstrap.min.js" rel="stylesheet">

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'HelveticaNeue-Light', 'Ubuntu', 'Droid Sans', sans-serif;
            font-size: 14px;
            line-height: 1.6;
        }
    </style>
</head>
<body class="container-fluid">


<div class="row">
    <!--<div class="col-md-4" style="max-width: 350px">-->
    <div class="col-md-3">
        <ul>
            <li><a href="#1">1. 简介</a></li>
            <li><a href="#2">2. 入门</a>
                <ul>
                    <li><a href="#anzhuang">安装</a></li>
                    <li><a href="#goujian-SQLFactory">构建 SQLFactory</a></li>
                    <li><a href="#cong-SQLFactory-huoqusql">从 SQLFactory 中获取 SQL</a>
                    </li>
                    <li>
                        <a href="#zuoyongyu-scope">作用域（Scope）和生命周期</a>
                    </li>
                </ul>
            </li>
            <li><a href="#3">3. SQLFactory 配置</a></li>
            <li>
                <a href="#4">4.
                    SQL类作为sql语句构建器使用</a>
                <ul>
                    <li><a href="#jiben-chaxun">基本查询</a></li>
                    <li><a href="#caozuofu-fangfa">使用操作符方法</a></li>
                    <li>
                        <a href="#lianjie-chaxun">使用连接查询/排序</a>
                    </li>
                    <li><a href="#fenzu-chaxun">分组查询</a></li>
                    <li><a href="#in-yujv">IN语句</a></li>
                    <li>
                        <a href="#zichaxun">使用$_$()方法进行子查询</a>
                    </li>
                    <li><a href="#andor">AND和OR结合使用</a></li>
                    <li>
                        <a href="#lambdasql">使用Lambda表达式简化构建动态sql</a>
                    </li>
                    <li><a href="#fenye">分页功能</a></li>
                    <li>
                        <a href="#insertupdatedelete">构建插入insert/修改update/删除delete语句</a>
                    </li>
                </ul>
            </li>
            <li><a href="#5">5.
                SQL构建器的执行功能</a>
                <ul>
                    <li><a href="#create_sqlfactory">创建SqlFactory</a></li>
                    <li><a href="#shezhi_canshu">设置参数方法</a></li>
                    <li><a href="#chaxun-fangfa">查询方法</a></li>
                    <li><a href="#zheng_shan_gai">增删改操作：</a></li>
                    <li>
                        <a href="#yuanxinxi">获取数据库元信息</a>
                    </li>
                    <li><a href="#shiwuguanli">事务管理</a></li>
                </ul>
            </li>
            <li><a href="#6">6. BaseDAO</a>
                <ul>
                    <li><a href="#shujv-zhunbei">数据准备</a>

                    </li>
                    <li><a href="#crud">基本使用方法 CRUD</a>

                    </li>
                    <li><a href="#applicationbasedao">定制你的ApplicationBaseDAO</a>

                    </li>
                    <li>
                        <a href="#sqlbasedao">SQL构建器在BaseDAO中的使用</a>
                    </li>
                </ul>
            </li>
            <li><a href="#7">7. 通用工具</a>
                <ul>
                    <li><a href="#sqlin">获取sql的IN列表</a></li>
                    <li><a href="#like">获取LIKE通配符</a></li>
                </ul>
            </li>
            <li><a href="#8">8. 配置项</a></li>
        </ul>
    </div>

    <!--<div class="col-md-9 pre-scrollable" style="max-height: 1000px">-->
    <div class="col-md-9">
        <!--class="row "-->

        <h1 id="1">1. 简介</h1>
        <p>
            FastSQL一个基于spring-jdbc的简单ORM框架，它支持sql构建、sql执行、命名参数绑定、查询结果自动映射和通用DAO。结合了Hibernate/JPA快速开发和Mybatis高效执行的优点。</p>
        <p>FastSQL可以完全满足你控制欲，可以用Java代码清晰又方便地写出sql语句并执行。</p>
        <h1 id="2">2. 入门</h1>
        <h2 id="anzhuang">安装</h2>
        <p>要使用 FastSQL， 只需将 fastsql-x.x.x.jar 文件置于 classpath 中即可（x.x.x为对应的版本号，下同）。</p>
        <p>如果使用 Maven 来构建项目，则需将下面的 dependency 代码置于 pom.xml 文件中：</p>
        <pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>top.fastsql<span
                    class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastsql<span
                    class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>x.x.x<span class="hljs-tag">&lt;/<span
                    class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</div></code></pre>
        <p>如果使用 Gradle 来构建项目，则需将下面的代码置于 build.gradle 文件的 dependencies 代码块中：</p>
        <pre class="hljs"><code><div>compile <span class="hljs-string">'top.fastsql:fastsql:x.x.x'</span>
</div></code></pre>
        <h2 id="goujian-SQLFactory">构建 SQLFactory</h2>
        <p>你可以直接从 Java 程序构建一个 SQLFactory ，如果使用SQL的执行功能，至少需要设置 DataSource 。</p>
        <pre class="hljs"><code><div><span
                class="hljs-comment">//新建一个DataSource（这里使用了Spring-Jdbc的SimpleDriverDataSource）</span>
DataSource dataSource = <span class="hljs-keyword">new</span> SimpleDriverDataSource([传入url,username等]);

SQLFactory sqlFactory = <span class="hljs-keyword">new</span> SQLFactory();
sqlFactory.setDataSource(dataSource);
</div></code></pre>
        <h2 id="cong-SQLFactory-huoqusql">从 SQLFactory 中获取 SQL</h2>
        <p>既然有了 SQLFactory ，我们就可以从中获得 SQL 的实例了。SQL类完全包含了面向数据库执行 sql 命令所需的所有方法。
            你可以通过 SQL 实例来构建并直接执行 SQL 语句。例如：</p>
        <pre class="hljs"><code><div>SQL sql = sqlFactory.createSQL();
Student student = sql.SELECT(<span class="hljs-string">"*"</span>).FROM(<span class="hljs-string">"student"</span>).WHERE(<span
                    class="hljs-string">"id=101"</span>).queryOne(Student.class);
</div></code></pre>
        <h2 id="zuoyongyu-scope">作用域（Scope）和生命周期</h2>
        <p><strong>SQLFactory</strong></p>
        <p>SQLFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。
            使用 SQLFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SQLFactory 被视为一种代码“坏味道（bad smell）”。
            因此 SQLFactory 的最佳作用域是应用的作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式
            （如果在Spring环境中，利用Spring容器的功能，你完全可以把它设置为一个单例bean）。</p>
        <p><strong>SQL</strong></p>
        <p>SQL 实例是有状态的 ，不是线程安全的，是不能被共享的。即使在同一个线程中每执行sql语句一次，都需要重新构建一个 SQL 实例。
            绝对不能将 SQL 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。</p>
        <h1 id="3">3. SQLFactory 配置</h1>
        <p>新建SQLFactory</p>
        <pre class="hljs"><code><div>SQLFactory sqlFactory = <span class="hljs-keyword">new</span> SQLFactory();
</div></code></pre>
        <p>指定DataSource</p>
        <pre class="hljs"><code><div>DataSource dataSource =  ... ;<span class="hljs-comment">//新建任意类型一个DataSource，如SimpleDriverDataSource（Spring内部简单的DataSource）或者支持连接池的DataSource</span>
sqlFactory.setDataSource(dataSource);
</div></code></pre>
        <p>设置数据源类型</p>
        <pre class="hljs"><code><div>sqlFactory.setDataSourceType(DataSourceType.POSTGRESQL);<span
                class="hljs-comment">//默认</span>
<span class="hljs-comment">//sqlFactory.setDataSourceType(DataSourceType.MY_SQL);</span>
<span class="hljs-comment">//sqlFactory.setDataSourceType(DataSourceType.ORACLE);</span>
</div></code></pre>
        <h1 id="4">4. SQL类作为sql语句构建器使用</h1>
        <p>Java程序员面对的最痛苦的事情之一就是在Java代码中嵌入SQL语句。<code>SQL</code>类可以简化你构建sql语句的过程。</p>
        <h2 id="jiben-chaxun">基本查询</h2>
        <p>SELECT方法可以传入一个可变参数，以便选择多列。(FastSQL中建议SQL关键字全部采用大写)</p>
        <pre class="hljs"><code><div>sqlFactory.createSQL().SELECT(<span class="hljs-string">"name"</span>, <span
                class="hljs-string">"age"</span>).FROM(<span class="hljs-string">"student"</span>).WHERE(<span
                class="hljs-string">"age&gt;10"</span>).build();
<span class="hljs-comment">//==&gt; SELECT name,age FROM student WHERE age&gt;10</span>
sqlFactory.createSQL().SELECT(<span class="hljs-string">"name"</span>, <span
                    class="hljs-string">"age"</span>).FROM(<span class="hljs-string">"student"</span>).WHERE(<span
                    class="hljs-string">"name='小红'"</span>).build();
<span class="hljs-comment">//==&gt; SELECT name,age FROM student WHERE name='小红'</span>
</div></code></pre>
        <p><code>WHERE()</code>关键字生成<code>WHERE 1=1</code>,如下</p>
        <pre class="hljs"><code><div>SQL sql = sqlFactory.createSQL().SELECT(<span
                class="hljs-string">"name"</span>, <span
                class="hljs-string">"age"</span>).FROM(<span class="hljs-string">"student"</span>).WHERE();
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">true</span>){
  sql.AND(<span class="hljs-string">"age &gt; 10"</span>);
}
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">false</span>){
  sql.AND(<span class="hljs-string">"age &lt; 8"</span>);
}

<span class="hljs-comment">//===&gt;SELECT name,age  FROM student  WHERE 1 = 1  AND age &gt; 10 </span>
</div></code></pre>
        <h2 id="caozuofu-fangfa">使用操作符方法</h2>
        <p>FastSQL提供了一些操作符方便SQL的构建，比如：</p>
        <pre class="hljs"><code><div>sqlFactory.createSQL()
    .SELECT(<span class="hljs-string">"name"</span>, <span class="hljs-string">"age"</span>)
    .FROM(<span class="hljs-string">"student"</span>)
    .WHERE(<span class="hljs-string">"age"</span>).lt(<span class="hljs-string">"10"</span>)
    .AND(<span class="hljs-string">"name"</span>).eq(<span class="hljs-string">"'小明'"</span>)
    .build();
<span class="hljs-comment">//==&gt; SELECT name,age FROM student WHERE age &gt; 10 AND name = '小明'</span>
</div></code></pre>
        <p>如下：</p>
        <table>
            <thead>
            <tr>
                <th style="text-align:left">方法</th>
                <th style="text-align:left">说明</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td style="text-align:left">eq(String)</td>
                <td style="text-align:left">生成 = ，并追加参数（equal的缩写）</td>
            </tr>
            <tr>
                <td style="text-align:left">gt(String)</td>
                <td style="text-align:left">生成 &gt; ，并追加参数（是greater than的缩写）</td>
            </tr>
            <tr>
                <td style="text-align:left">gtEq(String)</td>
                <td style="text-align:left">生成 &gt;= ，并追加参数（是greater than or equal的缩写）</td>
            </tr>
            <tr>
                <td style="text-align:left">lt(String)</td>
                <td style="text-align:left">生成 &lt; ，并追加参数（是less than的缩写 ）</td>
            </tr>
            <tr>
                <td style="text-align:left">ltEq(String)</td>
                <td style="text-align:left">生成 &lt;= ，并追加参数（是less than or equal的缩写）</td>
            </tr>
            <tr>
                <td style="text-align:left">nEq(String)</td>
                <td style="text-align:left">生成 != ，并追加参数（是not equal的缩写 ）</td>
            </tr>
            <tr>
                <td style="text-align:left">LIKE(String)</td>
                <td style="text-align:left">生成 LIKE ，并追加参数，</td>
            </tr>
            <tr>
                <td style="text-align:left">NOT_LIKE(String)</td>
                <td style="text-align:left">生成 NOT LIKE ，并追加参数</td>
            </tr>
            <tr>
                <td style="text-align:left">IS_NULL()</td>
                <td style="text-align:left">生成 IS NULL</td>
            </tr>
            <tr>
                <td style="text-align:left">IS_NOT_NULL()</td>
                <td style="text-align:left">生成 IS NOT NULL</td>
            </tr>
            <tr>
                <td style="text-align:left">eq()</td>
                <td style="text-align:left">生成 =</td>
            </tr>
            <tr>
                <td style="text-align:left">gt()</td>
                <td style="text-align:left">生成 &gt;</td>
            </tr>
            <tr>
                <td style="text-align:left">gtEq()</td>
                <td style="text-align:left">生成 &gt;=</td>
            </tr>
            <tr>
                <td style="text-align:left">lt()</td>
                <td style="text-align:left">生成 &lt;</td>
            </tr>
            <tr>
                <td style="text-align:left">ltEq()</td>
                <td style="text-align:left">生成 &lt;=</td>
            </tr>
            <tr>
                <td style="text-align:left">nEq()</td>
                <td style="text-align:left">生成 !=</td>
            </tr>
            <tr>
                <td style="text-align:left">LIKE()</td>
                <td style="text-align:left">生成 LIKE</td>
            </tr>
            <tr>
                <td style="text-align:left">NOT_LIKE()</td>
                <td style="text-align:left">生成 NOT LIKE</td>
            </tr>
            </tbody>
        </table>
        <p><strong>byType(Object)</strong></p>
        <p>这些方法仅仅是字符串连接：<code>eq(&quot;1&quot;)</code>生成<code>= 1</code> ，<code>eq(&quot;'1'&quot;)</code>会生成<code>=
            '1'</code>。byType(Object)方法可以根据类型生成你想要的sql字符串
        </p>
        <pre class="hljs"><code><div>sqlFactory.createSQL()
        .SELECT(<span class="hljs-string">"name"</span>, <span class="hljs-string">"age"</span>)
        .FROM(<span class="hljs-string">"student"</span>)
        .WHERE(<span class="hljs-string">"age"</span>).lt().byType(<span class="hljs-number">10</span>)
        .AND(<span class="hljs-string">"name"</span>).eq().byType(<span class="hljs-string">"小明"</span>)
        .build();
<span class="hljs-comment">//==&gt;SELECT name,age FROM student WHERE age &lt; 10 AND name = '小明'</span>
</div></code></pre>
        <table>
            <thead>
            <tr>
                <th style="text-align:left">方法</th>
                <th style="text-align:left">说明</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td style="text-align:left">byType(Object)</td>
                <td style="text-align:left">根据类型生成相应字符串 ，如 byType(1)生成1 ，byType(&quot;1&quot;)生成'1'</td>
            </tr>
            <tr>
                <td style="text-align:left">eqByType(Object)</td>
                <td style="text-align:left">使用 = 连接根据类型生成相应的字符串</td>
            </tr>
            </tbody>
        </table>
        <h2 id="lianjie-chaxun">使用连接查询/排序</h2>
        <p>查询不及格的成绩</p>
        <pre class="hljs"><code><div>sqlFactory.createSQL().SELECT(<span class="hljs-string">"s.name"</span>,<span
                class="hljs-string">"c.subject_name"</span>,<span class="hljs-string">"c.score_value"</span>)
        .FROM(<span class="hljs-string">"score c"</span>)
        .LEFT_JOIN_ON(<span class="hljs-string">"student s"</span>, <span class="hljs-string">"s.id=c.student_id"</span>)
        .WHERE(<span class="hljs-string">"c.score_value&lt;60"</span>)
        .ORDER_BY(<span class="hljs-string">"c.score_value"</span>)
        .build();
<span class="hljs-comment">/*
生成sql==&gt;

SELECT s.name, c.subject,c.score_value
FROM score c
LEFT OUTER JOIN student s ON (s.id = c.student_id)
WHERE c.score_value &lt; 60
ORDER BY c.score_value
*/</span>
</div></code></pre>
        <h2 id="fenzu-chaxun">分组查询</h2>
        <p>查询每个学生总分数</p>
        <pre class="hljs"><code><div>sqlFactory.createSQL().SELECT(<span class="hljs-string">"s.name"</span>, <span
                class="hljs-string">"sum(c.score_value) total_score"</span>)
        .FROM(<span class="hljs-string">"score c"</span>)
        .LEFT_JOIN_ON(<span class="hljs-string">"student s"</span>, <span class="hljs-string">"s.id=c.student_id"</span>)
        .GROUP_BY(<span class="hljs-string">"s.name"</span>)
        .build()
<span class="hljs-comment">/*
生成sql==&gt;

SELECT s.name, sum(c.score_value) total_score
FROM score c
LEFT OUTER JOIN student s ON (s.id = c.student_id)
GROUP BY s.name
*/</span>
</div></code></pre>
        <h2 id="in-yujv">IN语句</h2>
        <p>由于Jdbc规范不支持IN参数绑定，FastSQL提供了几种IN语句直接拼接的方式：</p>
        <pre class="hljs"><code><div><span class="hljs-comment">//1.使用字符串</span>
sqlFactory.createSQL().SELECT(<span class="hljs-string">"*"</span>)
   .FROM(<span class="hljs-string">"student"</span>)
   .WHERE(<span class="hljs-string">"name"</span>).IN(<span class="hljs-string">"('小明','小红')"</span>)
   .build();

<span class="hljs-comment">//2.使用集合（List,Set等）</span>
sqlFactory.createSQL().SELECT(<span class="hljs-string">"*"</span>)
   .FROM(<span class="hljs-string">"student"</span>)
   .WHERE(<span class="hljs-string">"name"</span>).IN(Lists.newArrayList(<span class="hljs-string">"小明"</span>,<span
                    class="hljs-string">"小红"</span>))
   .build();

<span class="hljs-comment">//3.使用数组</span>
sqlFactory.createSQL().SELECT(<span class="hljs-string">"*"</span>)
   .FROM(<span class="hljs-string">"student"</span>)
   .WHERE(<span class="hljs-string">"name"</span>).IN(<span class="hljs-keyword">new</span> Object[]{<span
                    class="hljs-string">"小明"</span>,<span class="hljs-string">"小红"</span>})<span
                    class="hljs-comment">//</span>
   .build();

<span class="hljs-comment">//生成sql==&gt; SELECT *  FROM student  WHERE name  IN ('小明','小红')</span>
</div></code></pre>
        <h2 id="zichaxun">使用$_$()方法进行子查询</h2>
        <p>查询大于平均分的成绩（可以使用 $_$()方法）</p>
        <pre class="hljs"><code><div>sqlFactory.createSQL().SELECT(<span class="hljs-string">"*"</span>)
   .FROM(<span class="hljs-string">"score"</span>)
   .WHERE(<span class="hljs-string">"score_value &gt;"</span>)
   .$_$(
         sqlFactory.createSQL().SELECT(<span class="hljs-string">"avg(score_value)"</span>).FROM(<span
                    class="hljs-string">"score"</span>)
    )
   .build();
<span class="hljs-comment">//生成sql==&gt;</span>
<span class="hljs-comment">//SELECT *  FROM score  </span>
<span class="hljs-comment">//WHERE score_value &gt;  ( SELECT avg(score_value)  FROM score  )</span>
</div></code></pre>
        <p>带有IN的子查询</p>
        <pre class="hljs"><code><div>sqlFactory.createSQL().SELECT(<span class="hljs-string">"*"</span>)
    .FROM(<span class="hljs-string">"score"</span>)
    .WHERE()
    .AND(<span class="hljs-string">"score"</span>)
    .IN().$_$(
         sqlFactory.createSQL().SELECT(<span class="hljs-string">"DISTINCT score_value"</span>).FROM(<span
                    class="hljs-string">"score"</span>)
    )
    .build();
<span class="hljs-comment">//生成sql==&gt; SELECT * FROM score WHERE 1 = 1 AND score IN (SELECT DISTINCT score_value FROM score)</span>
</div></code></pre>
        <h2 id="andor">AND和OR结合使用</h2>
        <p>如果查询年龄大于10岁，并且名字是小明或小红</p>
        <pre class="hljs"><code><div>sqlFactory.createSQL().SELECT(<span class="hljs-string">"*"</span>)
   .FROM(<span class="hljs-string">"student"</span>)
   .WHERE(<span class="hljs-string">"age&gt;10"</span>)
   .AND(<span class="hljs-string">"(name='小明' OR name='小红')"</span>)<span class="hljs-comment">//手动添加括号</span>
   .build();
<span class="hljs-comment">//或者</span>
sqlFactory.createSQL().SELECT(<span class="hljs-string">"*"</span>)
   .FROM(<span class="hljs-string">"student"</span>)
   .WHERE(<span class="hljs-string">"age&gt;10"</span>)
   .AND().$_$(<span class="hljs-string">"name='小明' OR name='小红'"</span>)<span class="hljs-comment">//$_$ 生成左右括号</span>
   .build();
</div></code></pre>
        <h2 id="lambdasql">使用Lambda表达式简化构建动态sql</h2>
        <ul>
            <li><code>ifTrue(boolean bool, Consumer&lt;SQL&gt; sqlConsumer)</code>:如果第1个参数为true，则执行第二个参数（Lambda表达式）
            </li>
            <li><code>ifNotEmpty(Collection&lt;?&gt; collection, Consumer&lt;SQL&gt; sqlConsumer)</code>:如果第1个参数长度大于0，则执行第二个参数（Lambda表达式）
            </li>
            <li><code>ifPresent(Object object, Consumer&lt;SQL&gt; sqlConsumer)</code>:如果第1个参数存在（不等于null且不为&quot;&quot;），则执行第二个参数（Lambda表达式）
            </li>
        </ul>
        <pre class="hljs"><code><div>sqlFactory.createSQL()
    .SELECT(<span class="hljs-string">"student"</span>)
    .WHERE(<span class="hljs-string">"id=:id"</span>)
    .ifTrue(<span class="hljs-keyword">true</span>, thisBuilder -&gt; thisBuilder.AND(<span class="hljs-string">"name=:name"</span>))
    .ifNotEmpty(names, thisBuilder -&gt; {
        System.out.println(<span class="hljs-string">"ifNotEmpty?"</span>);
        thisBuilder.AND(<span class="hljs-string">"name"</span>).IN(Lists.newArrayList(<span
                    class="hljs-string">"小明"</span>, <span class="hljs-string">"小红"</span>));
    })
    .ifPresent(<span class="hljs-string">""</span>,thisBuilder -&gt; {
        System.out.println(<span class="hljs-string">"ifPresent?"</span>);
        <span class="hljs-comment">//...处理其他流程语句...</span>
    })
    .build();
</div></code></pre>
        <p>输出：</p>
        <pre><code>ifNotEmpty?
SELECT student WHERE id=:id AND name=:name AND name  IN ('小明','小红')
</code></pre>
        <h2 id="fenye">分页功能</h2>
        <p><strong>使用原生关键字进行分页</strong></p>
        <pre class="hljs"><code><div>sqlFactory.createSQL().SELECT(<span class="hljs-string">"*"</span>).FROM(<span
                class="hljs-string">"student"</span>).LIMIT(<span class="hljs-number">10</span>).build();
sqlFactory.createSQL().SELECT(<span class="hljs-string">"*"</span>).FROM(<span class="hljs-string">"student"</span>).LIMIT(<span
                    class="hljs-number">5</span>, <span class="hljs-number">10</span>).build();  <span
                    class="hljs-comment">//postgresql中的写法</span>
sqlFactory.createSQL().SELECT(<span class="hljs-string">"*"</span>).FROM(<span class="hljs-string">"student"</span>).LIMIT(<span
                    class="hljs-number">10</span>).OFFSET(<span class="hljs-number">5</span>).build(); <span
                    class="hljs-comment">//mysql中的写法</span>
</div></code></pre>
        <p>生成如下SQL</p>
        <pre class="hljs"><code><div><span class="hljs-keyword">SELECT</span> * <span
                class="hljs-keyword">FROM</span> student <span class="hljs-keyword">LIMIT</span> <span
                class="hljs-number">10</span>
<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">LIMIT</span> <span
                    class="hljs-number">5</span>,<span class="hljs-number">10</span>
<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">LIMIT</span> <span
                    class="hljs-number">10</span> <span class="hljs-keyword">OFFSET</span> <span
                    class="hljs-number">5</span>
</div></code></pre>
        <p><strong>使用</strong> <code>pageThis(int,int)</code> <strong>分页方法进行分页</strong></p>
        <pre><code>//
sqlFactory.setDataSourceType(DataSourceType.POSTGRESQL); //使用枚举指定数据源类型
sqlFactory.createSQL().SELECT("*").FROM("student").pageThis(1,10).build();
</code></pre>
        <p>注意：如果不指定 dataSourceType，将会使用 FastSQLConfig#dataSourceType 的默认类型进行分页;</p>
        <p><strong>使用</strong> <code>countThis()</code> <strong>生成获取数量语句</strong></p>
        <pre class="hljs"><code><div><span class="hljs-comment">//countThis</span>
sqlFactory.createSQL().SELECT(<span class="hljs-string">"*"</span>).FROM(<span class="hljs-string">"student"</span>).countThis().buildAndPrintSQL();
</div></code></pre>
        <h2 id="insertupdatedelete">构建插入insert/修改update/删除delete语句</h2>
        <p><strong>插入</strong></p>
        <pre class="hljs"><code><div><span class="hljs-comment">//使用列</span>
sqlFactory.createSQL().INSERT_INTO(<span class="hljs-string">"student"</span>, <span
                    class="hljs-string">"id"</span>, <span class="hljs-string">"name"</span>, <span
                    class="hljs-string">"age"</span>)
                .VALUES(<span class="hljs-string">":id"</span>, <span class="hljs-string">":name"</span>, <span
                    class="hljs-string">":age"</span>).build();
<span class="hljs-comment">//=&gt;INSERT INTO student (id,name,age)  VALUES (:id,:name,:age)</span>

<span class="hljs-comment">//不使用列</span>
sqlFactory.createSQL().INSERT_INTO(<span class="hljs-string">"student"</span>).VALUES(<span
                    class="hljs-string">":id"</span>, <span class="hljs-string">":name"</span>, <span
                    class="hljs-string">":age"</span>).build();
<span class="hljs-comment">//=&gt;INSERT INTO student VALUES (:id,:name,:age)</span>
</div></code></pre>
        <p><strong>修改</strong></p>
        <p>SET(String column, String value) :SET关键字</p>
        <p>setOne(String column, String value) :追加一个值</p>
        <pre class="hljs"><code><div>sqlFactory.createSQL().UPDATE(<span
                class="hljs-string">"student"</span>).SET(<span
                class="hljs-string">"name"</span>,<span class="hljs-string">"'Jack'"</span>).setOne(<span
                class="hljs-string">"age"</span>,<span
                class="hljs-string">"9"</span>).WHERE(<span class="hljs-string">"name"</span>).eq(<span
                class="hljs-string">"'Mike'"</span>).build();
<span class="hljs-comment">//=&gt;  UPDATE student SET name='Jack',age=9 WHERE name = 'Mike'              </span>
</div></code></pre>
        <p><strong>构建删除语句</strong></p>
        <pre class="hljs"><code><div>sqlFactory.createSQL().DELETE_FROM(<span
                class="hljs-string">"student"</span>).WHERE(<span
                class="hljs-string">"id=:id"</span>).build();
<span class="hljs-comment">//=&gt;DELETE FROM student WHERE id=:id                </span>
</div></code></pre>
        <h1 id="5">5. SQL构建器的执行功能</h1>
        <h2 id="create_sqlfactory">创建SqlFactory</h2>
        <pre class="hljs"><code><div><span
                class="hljs-comment">//创建任意DataSource对象（这里使用了spring自带的数据源SimpleDriverDataSource）</span>
DataSource dataSource = <span class="hljs-keyword">new</span> SimpleDriverDataSource(
                <span class="hljs-keyword">new</span> Driver(), <span class="hljs-string">"jdbc:postgresql://192.168.0.226:5432/picasso_dev2?stringtype=unspecified"</span>,
                <span class="hljs-string">"developer"</span>, <span class="hljs-string">"password"</span>);

<span class="hljs-comment">//创建SqlFactory</span>
SqlFactory sqlFactory = <span class="hljs-keyword">new</span> SqlFactory();
sqlFactory.setDataSource(dataSource);
sqlFactory.setDataSourceType(DataSourceType.MY_SQL);
</div></code></pre>
        <h2 id="shezhi_canshu">设置参数方法</h2>
        <p>FastSQL支持多种传入命名参数的方法：</p>
        <ul>
            <li><code>parameter(SqlParameterSource sqlParameterSource)</code>
                支持传入SqlParameterSource类型的参数（兼容spring-jdbc）
            </li>
            <li><code>beanParameter(Object dto)</code>方法可以传入对象参数</li>
            <li><code>mapParameter(Map&lt;String, Object&gt; map)</code>支持传入Map类型参数</li>
            <li><code>mapItemsParameter(Object... param)</code>支持多个key-value形式的参数，比如<code>mapItemsParameter(&quot;id&quot;,
                12345,&quot;name&quot;,&quot;小明&quot;)</code></li>
            <li><code>beanAndMapParameter(Object dto, Map&lt;String, Object&gt; map)</code>
                支持两种不同的参数组合，后一个会覆盖前面的相同名字的参数
            </li>
            <li><code>addParameterMapItem(String key, Object value)</code>可以为以上几种传参方法追加参数</li>
        </ul>
        <p>FastSQL也支持?占位符和可变参数：</p>
        <ul>
            <li><code>varParameter(Object... vars)</code> 可以调用多次</li>
        </ul>
        <p><strong>示例</strong></p>
        <p>使用beanParameter方法支持传入一个参数bean</p>
        <pre class="hljs"><code><div><span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span
                    class="hljs-title">StudentDTO</span></span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;
}
</div></code></pre>
        <pre class="hljs"><code><div>StudentDTO dto =<span class="hljs-keyword">new</span> StudentDTO();
dto.setName=<span class="hljs-string">"小明"</span>;
dto.setAge=<span class="hljs-number">10</span>;

sqlFactory.createSQL().SELECT(<span class="hljs-string">"*"</span>)
    .FROM(<span class="hljs-string">"student"</span>)
    .WHERE(<span class="hljs-string">"name=:name"</span>)
    .AND(<span class="hljs-string">"age&gt;:age"</span>)
    .beanParameter(dto)  <span class="hljs-comment">//设置一个DTO查询参数</span>
    .queryList(StudVO.class);

</div></code></pre>
        <p>使用mapParameter方法并追加参数</p>
        <pre class="hljs"><code><div>Map&lt;String,Object&gt; param = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
map.put(<span class="hljs-string">"name"</span>,<span class="hljs-string">"李%"</span>);

sqlFactory.createSQL()
    .SELECT(<span class="hljs-string">"*"</span>)
    .FROM(<span class="hljs-string">"student"</span>)
    .WHERE(<span class="hljs-string">"name"</span>).LIKE(<span class="hljs-string">":name"</span>)
    .AND(<span class="hljs-string">"age &gt; :age"</span>)
    .beanParameter(param)  <span class="hljs-comment">//设置一个map参数</span>
    .addParameterMapItem(<span class="hljs-string">"age"</span>,<span class="hljs-number">12</span>) <span
                    class="hljs-comment">//追加</span>
    .queryList(Student.class);

</div></code></pre>
        <p>使用varParameter方法--支持?占位符和可变参数</p>
        <pre><code>SQL sql = sqlFactory.createSQL();
sql.INSERT_INTO("student", "id", "name", "age")
    .VALUES("?", "?", "?")
    .varParameter("123", "小明")
    .varParameter(12)
    .update();
</code></pre>
        <h2 id="chaxun-fangfa">查询方法</h2>
        <p><strong>查询方法解析</strong></p>
        <ul>
            <li><code>T queryOne(Class&lt;T&gt; returnClassType)</code>查询单行结果封装为一个对象,参数可以是可以为String/Integer/Long/Short/BigDecimal/BigInteger/Float/Double/Boolean或者任意POJO的class。
            </li>
            <li><code>Map&lt;String, Object&gt; queryMap()</code>查询单行结果封装为Map</li>
            <li><code>List&lt;T&gt; queryList(Class&lt;T&gt; returnClassType)</code>查询多行结果封装为一个对象列表</li>
            <li><code>List&lt;Map&lt;String, Object&gt;&gt; queryMapList()</code>查询多行结果封装为Map数组</li>
            <li><code>List&lt;Object[]&gt; queryArrayList()</code> 查询结果封装为泛型为Object数组的列表</li>
            <li><code>ResultPage&lt;T&gt; queryPage(int page, int perPage, Class&lt;T&gt; returnClassType)</code>
                查询结果页
            </li>
        </ul>
        <p><strong>示例</strong></p>
        <p>StudentVO是查询视图类，包含name和age字段；StudentDTO是查询参数类，包含name字段。</p>
        <pre class="hljs"><code><div><span class="hljs-comment">//queryList可以查询列表，可以是基本类型列表或对象列表</span>
List&lt;String&gt; strings = sqlFactory.createSQL().SELECT(<span class="hljs-string">"name"</span>)
                .FROM(<span class="hljs-string">"student"</span>)
                .queryList(String.class); <span class="hljs-comment">//这里执行查询列表并指定返回类型</span>

List&lt;StudVO&gt; studVOList = sqlFactory.createSQL().SELECT(<span class="hljs-string">"name"</span>, <span
                    class="hljs-string">"age"</span>)
                            .FROM(<span class="hljs-string">"student"</span>)
                            .WHERE(<span class="hljs-string">"name=:name"</span>)
                            .beanParameter(<span class="hljs-keyword">new</span> StudentDTO())  <span
                    class="hljs-comment">//设置一个DTO查询参数</span>
                            .queryList(StudVO.class);     <span class="hljs-comment">//查询一个对象列表</span>

<span class="hljs-comment">//queryOne可以查询一个值，可以是基本类型  或 对象 </span>
String name = sqlFactory.createSQL().SELECT(<span class="hljs-string">"name"</span>)
                 .FROM(<span class="hljs-string">"student"</span>)
                 .WHERE(<span class="hljs-string">"id=:id"</span>)
                 .AND(<span class="hljs-string">"name=:name"</span>)
                 .mapItemsParameter(<span class="hljs-string">"id"</span>, <span class="hljs-number">12345</span>) <span
                    class="hljs-comment">//可以传入多个k-v值，，还可以调用parameterMap传入Map参数，</span>
                 .addParameterMapItem(<span class="hljs-string">"name"</span>, <span
                    class="hljs-string">"Jack"</span>)<span
                    class="hljs-comment">// 使用addParameterMapItem追加k-v值</span>
                 .queryOne(String.class);  <span class="hljs-comment">//这里执行查询一个对象（基本类型）并指定返回类型 </span>

StudVO studVO = sqlFactory.createSQL().SELECT(<span class="hljs-string">"name"</span>, <span
                    class="hljs-string">"age"</span>)
                   .FROM(<span class="hljs-string">"student"</span>)
                   .WHERE(<span class="hljs-string">"name=:name"</span>)
                   .beanParameter(<span class="hljs-keyword">new</span> StudentDTO())  <span class="hljs-comment">//设置一个DTO</span>
                   .queryOne(StudVO.class);     <span class="hljs-comment">//查询一个对象</span>

<span class="hljs-comment">//queryPage查询分页</span>
ResultPage&lt;StudVO&gt; studVOResultPage =sqlFactory.createSQL().SELECT(<span class="hljs-string">"name"</span>, <span
                    class="hljs-string">"age"</span>)
                                        .FROM(<span class="hljs-string">"student"</span>)
                                        .queryPage(<span class="hljs-number">1</span>, <span
                    class="hljs-number">10</span>, StudVO.class);  <span
                    class="hljs-comment">//分页查询（第一页，每页10条记录）</span>
<span class="hljs-comment">//根据特定数据库进行分页查询                    </span>
ResultPage&lt;StudVO&gt; studVOResultPage =sqlFactory.createSQL().SELECT(<span class="hljs-string">"name"</span>, <span
                    class="hljs-string">"age"</span>)
                                        .FROM(<span class="hljs-string">"student"</span>)
                                        .queryPage(<span class="hljs-number">1</span>, <span
                    class="hljs-number">10</span>, StudVO.class, DbType.MY_SQL);
</div></code></pre>
        <p>注意1：queryOne调用后，如果查询的值不存在是不会抛出EmptyResultDataAccessException，而是返回null，所以要用包装类型接收他的值而不是基本类型，并判断非空性</p>
        <p>注意2：queryPage返回的是ResultPage对象</p>
        <h2 id="zheng_shan_gai">增删改操作：</h2>
        <p>使用update方法</p>
        <pre class="hljs"><code><div><span class="hljs-comment">//插入</span>
sqlFactory.createSQL().INSERT_INTO(<span class="hljs-string">"student"</span>, <span
                    class="hljs-string">"id"</span>, <span class="hljs-string">"name"</span>, <span
                    class="hljs-string">"age"</span>)
        .VALUES(<span class="hljs-string">":id"</span>, <span class="hljs-string">":name"</span>, <span
                    class="hljs-string">":age"</span>)
        .mapItemsParameter(<span class="hljs-string">"id"</span>, <span class="hljs-number">678</span>, <span
                    class="hljs-string">"name"</span>, <span class="hljs-string">"kjs345a354dfk"</span>, <span
                    class="hljs-string">"age"</span>, <span class="hljs-number">123</span>)
        .update();

<span class="hljs-comment">//修改</span>
sqlFactory.createSQL().UPDATE(<span class="hljs-string">"student"</span>)
        .SET(<span class="hljs-string">"name"</span>,<span class="hljs-string">":name"</span>)
        .WHERE(<span class="hljs-string">"id=678"</span>)
        .mapItemsParameter(<span class="hljs-string">"id"</span>, <span class="hljs-number">678</span>, <span
                    class="hljs-string">"name"</span>, <span class="hljs-string">"Rose"</span>, <span
                    class="hljs-string">"age"</span>, <span class="hljs-number">123</span>)
        .update();
<span class="hljs-comment">//删除</span>
sqlFactory.createSQL().DELETE_FROM(<span class="hljs-string">"student"</span>)
        .WHERE(<span class="hljs-string">"id=:id"</span>)
        .mapItemsParameter(<span class="hljs-string">"id"</span>, <span class="hljs-number">678</span>)
        .update();
</div></code></pre>
        <h2 id="yuanxinxi">获取数据库元信息</h2>
        <pre class="hljs"><code><div><span class="hljs-comment">//表名称</span>
List&lt;String&gt; tableNames = sqlFactory.createSQL().getTableNames();
<span class="hljs-comment">//列名称</span>
List&lt;String&gt; columnNames = sqlFactory.createSQL().getColumnNames(<span class="hljs-string">"student"</span>);
<span class="hljs-comment">//列对象</span>
List&lt;ColumnMetaData&gt; columnMetaDataList = sqlFactory.createSQL().getColumnMetaDataList(<span class="hljs-string">"sys_dict"</span>);

</div></code></pre>
        <h2 id="shiwuguanli">事务管理</h2>
        <p>手动事务：FastSQL事务管理使用Spring的工具类<code>org.springframework.jdbc.datasource.DataSourceUtils</code></p>
        <pre class="hljs"><code><div>Connection connection = DataSourceUtils.getConnection(dataSource);<span
                class="hljs-comment">//开启事务</span>
connection.setAutoCommit(<span class="hljs-keyword">false</span>);<span class="hljs-comment">//关闭自动提交</span>

sqlFactory.createSQL()
     .INSERT_INTO(<span class="hljs-string">"sys_users"</span>, <span class="hljs-string">"id"</span>).VALUES(<span
                    class="hljs-string">":id"</span>)
     .mapItemsParameter(<span class="hljs-string">"id"</span>, <span class="hljs-number">456</span>)
     .update();

sqlFactory.createSQL()
    .INSERT_INTO(<span class="hljs-string">"sys_users"</span>, <span class="hljs-string">"id"</span>).VALUES(<span
                    class="hljs-string">":id"</span>)
    .mapItemsParameter(<span class="hljs-string">"id"</span>, <span class="hljs-number">234</span>)
    .update();

<span class="hljs-comment">//connection.rollback(); //回滚</span>

connection.commit();<span class="hljs-comment">//提交事务</span>
</div></code></pre>
        <h1 id="6">6. BaseDAO</h1>
        <h2 id="shujv-zhunbei">数据准备</h2>
        <h3 id="entity">Entity实体类</h3>
        <p>注解如下</p>
        <ol>
            <li>@Table 非必需，如果不写表名称将会被解析为student（根据类名的下划线形式）</li>
            <li>@Id 必须存在，对应表的主键</li>
            <li>@Entity 非必需，标识一个实体，为了兼容JPA标准建议加上</li>
        </ol>
        <pre class="hljs"><code><div><span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table</span>(name=<span class="hljs-string">"student"</span>)
<span class="hljs-meta">@Data</span>  <span class="hljs-comment">//use lombok</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span
                    class="hljs-title">Student</span> </span>{
    <span class="hljs-meta">@Id</span>
    <span class="hljs-keyword">private</span> String id;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> Integer age;
    <span class="hljs-keyword">private</span> LocalDate birthday;
    <span class="hljs-keyword">private</span> String homeAddress;
}

</div></code></pre>
        <p>新建DAO层数据访问类, 并继承BaseDAO类，会自动继承BaseDAO中的方法(详见第2部分）</p>
        <h3 id="daospring">DAO类在Spring环境中</h3>
        <p>DAO层：</p>
        <pre class="hljs"><code><div><span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span
                    class="hljs-title">StudentDAO</span> <span class="hljs-keyword">extends</span> <span
                    class="hljs-title">BaseDAO</span>&lt;<span
                    class="hljs-title">Student</span>,<span class="hljs-title">String</span>&gt; </span>{

}
</div></code></pre>
        <p>如果设置了SQLFactory作为一个Spring的@Bean ,将会自动注入。在Service中，你就可以使用这个DAO：</p>
        <pre class="hljs"><code><div><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span
                    class="hljs-title">StudentService</span> </span>{
    <span class="hljs-meta">@Autowire</span>
    <span class="hljs-keyword">private</span> StudentDAO studentDAO;

    <span class="hljs-meta">@Transactional</span> <span class="hljs-comment">//如果需要事务--org.springframework.transaction.annotation.Transactional</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span
            class="hljs-title">test1</span><span class="hljs-params">()</span></span>{
        studentDAO.XXX();<span class="hljs-comment">//调用任意方法</span>
    }

}
</div></code></pre>
        <h3 id="daospring">DAO类在非Spring环境中</h3>
        <pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span
                class="hljs-keyword">class</span> <span class="hljs-title">StudentDAO</span> <span
                class="hljs-keyword">extends</span> <span class="hljs-title">BaseDAO</span>&lt;<span
                class="hljs-title">Student</span>,<span class="hljs-title">String</span>&gt; </span>{

}
</div></code></pre>
        <pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span
                class="hljs-keyword">class</span> <span class="hljs-title">Test</span>  </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span
            class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        SQLFactory sqlFactory = ...

        StudentDAO studentDAO= <span class="hljs-keyword">new</span> StudentDAO();
        studentDAO.setSqlFactory(sqlFactory);<span class="hljs-comment">//手动注入</span>
        <span class="hljs-comment">//执行操作</span>
        studentDAO.XXX();
    }
}
</div></code></pre>
        <h2 id="crud">基本使用方法 CRUD</h2>
        <p>CRUD 是四种数据操作的简称：C 表示创建，R 表示读取，U 表示更新，D 表示删除。BaseDAO 自动创建了处理数据表中数据的方法。</p>
        <h3 id="">数据插入</h3>
        <p>方法 <code>int insert(E entity)</code>，插入对象中的值到数据库，null值在生成的sql语句中会设置为NULL</p>
        <pre class="hljs"><code><div>Student student = <span class="hljs-keyword">new</span> Student();
student.setId(UUID.randomUUID().toString());
student.setName(<span class="hljs-string">"小丽"</span>);
student.setBirthday(LocalDate.now());<span class="hljs-comment">//这里使用jdk8时间类型</span>
student.setHomeAddress(<span class="hljs-string">""</span>);

studentDao.insert(student);<span class="hljs-comment">//获取保存成功的id</span>

<span class="hljs-comment">//等价如下SQL语句（注意：age被设置为null）</span>
<span class="hljs-comment">//INSERT INTO student(id,name,age,birthday,home_address) VALUES ('622bca40-4c64-43aa-8819-447718bdafa5','小丽',NULL,'2017-07-11','')</span>

</div></code></pre>
        <p>方法 <code>int insertSelective(E entity)</code>，插入对象中非null的值到数据库</p>
        <pre class="hljs"><code><div>Student student = <span class="hljs-keyword">new</span> Student();
student.setId(UUID.randomUUID().toString());
student.setName(<span class="hljs-string">"小丽"</span>);
student.setBirthday(<span class="hljs-keyword">new</span> Date());
student.setHomeAddress(<span class="hljs-string">""</span>);
studentDao.insertSelective(student);

<span class="hljs-comment">//等价如下SQL语句（注意：没有对age进行保存，在数据库层面age将会保存为该表设置的默认值，如果没有设置默认值，将会被保存为null ）</span>
<span class="hljs-comment">//===&gt;INSERT INTO student(id,name,birthday,home_address)  VALUES  ('622bca40-4c64-43aa-8819-447718bdafa5','小丽','2017-07-11','')</span>
</div></code></pre>
        <h3 id="">数据修改</h3>
        <p>方法 <code>int update(E entity)</code> ,根据对象进行更新（null字段在数据库中将会被设置为null），对象中@id字段不能为空</p>
        <pre class="hljs"><code><div><span class="hljs-comment">//待更新</span>
</div></code></pre>
        <p>方法 <code>int updateSelective(E entity)</code>,根据对象进行更新（只更新实体中非null字段），对象中@id字段不能为空</p>
        <pre class="hljs"><code><div><span class="hljs-comment">//待更新</span>
</div></code></pre>
        <p>方法 <code>int updateByColumn(E entity, String... columns)</code>,根据id更新可变参数columns列，对象中@id字段不能为空</p>
        <pre><code>Student student = studentDAO.selectOneById("11111111-1111-1111-1111-111111111111");
student.setAge(19);
studentDAO.updateByColumn(student,"age");

//===>UPDATE student SET age=? WHERE id=?
</code></pre>
        <h3 id="">数据删除</h3>
        <p>方法 <code>int deleteOneById(String id)</code> 根据id删除数据</p>
        <pre class="hljs"><code><div><span class="hljs-keyword">int</span> num = studentDao.deleteOneById(<span
                class="hljs-string">"22b66bcf-1c2e-4713-b90d-eab17182b565"</span>);<span
                class="hljs-comment">//获取删除的行数量</span>
<span class="hljs-comment">//===&gt;DELETE FROM student WHERE id='22b66bcf-1c2e-4713-b90d-eab17182b565'</span>
</div></code></pre>
        <p>方法 <code>int deleteAll()</code>,删除某个表所有行</p>
        <pre class="hljs"><code><div><span class="hljs-keyword">int</span> number = studentDao.deleteAll();<span
                class="hljs-comment">//获取删除的行数量</span>
<span class="hljs-comment">// ===&gt;DELETE FROM student</span>
</div></code></pre>
        <p>方法 <code>int[] deleteInBatch(List&lt;String&gt; ids)</code> ,根据id列表批量删除数据(所有删除语句将会一次性提交到数据库)</p>
        <pre class="hljs"><code><div>List&lt;String&gt; ids = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
ids.add(<span class="hljs-string">"467641d2-e344-45e9-9e0e-fd6152f80867"</span>);
ids.add(<span class="hljs-string">"881c80a1-8c93-4bb7-926e-9a8bc9799a72"</span>);
studentDao.deleteInBatch(ids);<span class="hljs-comment">//返回成功删除的数量</span>
</div></code></pre>
        <p>方法<code>int deleteWhere(String sqlCondition, Object... values)</code>，根据条件删除</p>
        <h3 id="">单条数据查询</h3>
        <p>方法 <code>E selectOneById(String id)</code></p>
        <p>通过id查询一个对象</p>
        <pre class="hljs"><code><div>Student student = studentDao.selectOneById(<span
                class="hljs-string">"12345678"</span>);<span
                class="hljs-comment">//查询id为12345678的数据，并封装到Student类中</span>
</div></code></pre>
        <p>方法 <code>E selectOneWhere(String sqlCondition, Object... values)</code>,通过语句查询（返回多条数据将会抛出运行时异常,为了防止sql语句在service层滥用，可变参数最多支持三个）
        </p>
        <pre class="hljs"><code><div>Student student = studentDao.selectOneWhere(<span class="hljs-string">"name=? AND home_address=?"</span>, <span
                class="hljs-string">"小明"</span>, <span class="hljs-string">"成都"</span>);
</div></code></pre>
        <p>方法 <code>protected E selectOneWhere(String sqlCondition, SqlParameterSource parameterSource)</code>
            查询一条数据，protected，只能在子类中使用</p>
        <h3 id="">多条数据查询</h3>
        <p>方法 <code>List&lt;E&gt; selectWhere(String sqlCondition, Object... values)</code>,用法与selectOneWhere()相同，可以返回一条或多条数据，可变参数最多支持三个
        </p>
        <pre class="hljs"><code><div>List&lt;Student&gt; studentList  =  studentDao.selectWhere(<span
                class="hljs-string">"name=?"</span>, <span
                class="hljs-string">"小明"</span>);
List&lt;Student&gt; studentList  =  studentDao.selectWhere(<span class="hljs-string">"ORDER BY age"</span>);
List&lt;Student&gt; studentList  =  studentDao.selectWhere(<span class="hljs-string">"home_address IS NULL ORDER BY age DESC"</span>);
<span class="hljs-comment">//...</span>
</div></code></pre>
        <p>方法 <code>List&lt;E&gt; selectAll()</code> 查询所有</p>
        <pre class="hljs"><code><div>List&lt;Student&gt; allStudents  =  studentDao.selectAll();
</div></code></pre>
        <p>方法 <code>protected List&lt;E&gt; selectWhere(String sqlCondition, SqlParameterSource
            parameterSource)</code>可以返回一条或多条数据，
            protected，只能在子类中使用</p>
        <h3 id="">分页查询</h3>
        <p>方法 <code>ResultPage&lt;E&gt; selectPageWhere(String sqlCondition, int pageNumber, int perPage, Object...
            values)</code></p>
        <p>方法 <code>protected ResultPage&lt;E&gt; selectPageWhere(String sqlCondition, int pageNumber, int perPage,
            SqlParameterSource parameterSource)</code> ， protected，只能在子类中使用</p>
        <p>方法 <code>ResultPage&lt;E&gt; selectPage(int pageNumber, int perPage)</code></p>
        <h3 id="">其他查询</h3>
        <p>方法 <code>int countWhere(String sqlCondition, Object... values)</code>,通过条件查询数量</p>
        <pre class="hljs"><code><div><span class="hljs-keyword">int</span> countWhere = studentDao.countWhere(<span
                class="hljs-string">"age &gt;= 20"</span>); <span class="hljs-comment">//查找年龄大于等于20的学生</span>
<span class="hljs-keyword">int</span> countWhere = studentDao.countWhere(<span class="hljs-string">"age &gt; ?"</span> , <span
                    class="hljs-number">10</span>); <span class="hljs-comment">//查找年龄大于10的学生</span>
</div></code></pre>
        <p>方法 <code>protected int countWhere(String sqlCondition, SqlParameterSource parameterSource)</code>,通过条件查询数量，
            protected，只能在子类中使用</p>
        <pre class="hljs"><code><div><span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span
                    class="hljs-title">BizPhotoDAO</span> <span class="hljs-keyword">extends</span> <span
                    class="hljs-title">ApplicationBaseDAO</span>&lt;<span
                    class="hljs-title">BizPhotoPO</span>, <span class="hljs-title">String</span>&gt; </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span
            class="hljs-title">countByName</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> countWhere(<span class="hljs-string">"photo_name=:name"</span>, <span
                    class="hljs-keyword">new</span> MapSqlParameterSource().addValue(<span
                    class="hljs-string">"name"</span>, <span class="hljs-string">"物品照片"</span>));
    }
}
</div></code></pre>
        <p>方法 <code>int count()</code> 查询表总数量</p>
        <h2 id="applicationbasedao">定制你的ApplicationBaseDAO</h2>
        <p>建议在你的程序中实现ApplicationBaseDAO，可以</p>
        <ol>
            <li>定制一些通用方法</li>
            <li>设置多数据库支持</li>
            <li>设置BaseDAO中的触发器</li>
        </ol>
        <pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span
                class="hljs-keyword">abstract</span> <span
                class="hljs-class"><span class="hljs-keyword">class</span> <span
                class="hljs-title">ApplicationBaseDAO</span>&lt;<span
                class="hljs-title">E</span>, <span class="hljs-title">ID</span>&gt; <span
                class="hljs-keyword">extends</span> <span class="hljs-title">BaseDAO</span>&lt;<span
                class="hljs-title">E</span>, <span
                class="hljs-title">ID</span>&gt; </span>{
  <span class="hljs-comment">//添加方法等</span>
}

<span class="hljs-comment">////我们的StudentDAO此时应该继承ApplicationBaseDAO</span>
<span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span
                    class="hljs-title">StudentDAO</span> <span class="hljs-keyword">extends</span> <span
                    class="hljs-title">ApplicationBaseDAO</span>&lt;<span
                    class="hljs-title">Student</span>,<span class="hljs-title">String</span>&gt; </span>{

}
</div></code></pre>
        <h3 id="">定制通用方法</h3>
        <p>如下，增加了一个名为logicDelete的逻辑删除方法，将会作用于继承于它的每个DAO</p>
        <pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span
                class="hljs-keyword">abstract</span> <span
                class="hljs-class"><span class="hljs-keyword">class</span> <span
                class="hljs-title">ApplicationBaseDAO</span>&lt;<span
                class="hljs-title">E</span>, <span class="hljs-title">ID</span>&gt; <span
                class="hljs-keyword">extends</span> <span class="hljs-title">BaseDAO</span>&lt;<span
                class="hljs-title">E</span>, <span
                class="hljs-title">ID</span>&gt; </span>{
  <span class="hljs-comment">//...其他方法</span>

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span
          class="hljs-title">logicDelete</span><span class="hljs-params">(ID id)</span> </span>{
      <span class="hljs-comment">//每个表都有一个defunct，1表示已（逻辑）删除</span>
      namedParameterJdbcTemplate.getJdbcOperations().update(<span class="hljs-string">"UPDATE "</span> + <span
                    class="hljs-keyword">this</span>.tableName + <span class="hljs-string">" SET defunct = 1"</span>);
  }

  <span class="hljs-comment">//...其他方法</span>
}
</div></code></pre>
        <p>上面的logicDelete方法使用了tableName这个变量，BaseDAO中的部分可用变量为</p>
        <pre><code>Class<E> entityClass; //DAO对应的实体类
Class<ID> idClass;  //标识为@Id的主键类型

Logger log; //日志，可以在实现类中直接使用

String className; //实体类名
String tableName; //表名

Field idField;  //@Id对应的字段引用
String idColumnName; //表主键列名

namedParameterJdbcTemplate //jdbc模板

//...待更新

</code></pre>
        <h3 id="">设置多数据源支持</h3>
        <pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span
                class="hljs-keyword">abstract</span> <span
                class="hljs-class"><span class="hljs-keyword">class</span> <span
                class="hljs-title">OracleApplicationBaseDAO</span>&lt;<span class="hljs-title">E</span>, <span
                class="hljs-title">ID</span>&gt; <span class="hljs-keyword">extends</span> <span
                class="hljs-title">BaseDAO</span>&lt;<span class="hljs-title">E</span>, <span
                class="hljs-title">ID</span>&gt; </span>{
      <span class="hljs-comment">//重写setSqlFactory方法</span>
      <span class="hljs-meta">@Autowired</span>
      <span class="hljs-meta">@Qualifier</span>(<span class="hljs-string">"sqlFactory1"</span>)<span
                    class="hljs-comment">//===&gt;根据名称注入</span>
      <span class="hljs-meta">@Override</span>
      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span
              class="hljs-keyword">void</span> <span class="hljs-title">setSqlFactory</span><span class="hljs-params">(SQLFactory sqlFactory)</span> </span>{
          <span class="hljs-keyword">super</span>.setSqlFactory(sqlFactory);
      }
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span
                    class="hljs-keyword">class</span> <span
                    class="hljs-title">MySqlApplicationBaseDAO</span>&lt;<span
                    class="hljs-title">E</span>, <span class="hljs-title">ID</span>&gt; <span
                    class="hljs-keyword">extends</span> <span class="hljs-title">BaseDAO</span>&lt;<span
                    class="hljs-title">E</span>, <span class="hljs-title">ID</span>&gt; </span>{
      <span class="hljs-comment">//重写setSqlFactory</span>
      <span class="hljs-meta">@Autowired</span>
      <span class="hljs-meta">@Qualifier</span>(<span class="hljs-string">"sqlFactory2"</span>)<span
                    class="hljs-comment">//===&gt;根据名称注入</span>
      <span class="hljs-meta">@Override</span>
      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span
              class="hljs-keyword">void</span> <span class="hljs-title">setSqlFactory</span><span class="hljs-params">(SQLFactory sqlFactory)</span> </span>{
          <span class="hljs-keyword">super</span>.setSqlFactory(sqlFactory);
       }}
}
</div></code></pre>
        <h3 id="basedao">设置BaseDAO中的拦截器</h3>
        <pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span
                class="hljs-keyword">abstract</span> <span
                class="hljs-class"><span class="hljs-keyword">class</span> <span
                class="hljs-title">ApplicationBaseDAO</span>&lt;<span
                class="hljs-title">E</span>, <span class="hljs-title">ID</span>&gt; <span
                class="hljs-keyword">extends</span> <span class="hljs-title">BaseDAO</span>&lt;<span
                class="hljs-title">E</span>, <span
                class="hljs-title">ID</span>&gt; </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span
            class="hljs-title">ApplicationBaseDAO</span><span class="hljs-params">()</span> </span>{
         <span class="hljs-comment">// 1.设置触发器开关</span>
         <span class="hljs-keyword">this</span>.useBeforeInsert = <span class="hljs-keyword">true</span>; <span
                    class="hljs-comment">//在插入前执行</span>
         <span class="hljs-keyword">this</span>.useBeforeUpdate = <span class="hljs-keyword">true</span>; <span
                    class="hljs-comment">//在更新前执行</span>
    }

    <span class="hljs-comment">//2.重写触发器相关方法</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span
            class="hljs-title">beforeInsert</span><span class="hljs-params">(E object)</span> </span>{
        EntityRefelectUtils.setFieldValue(object, idField, UUID.randomUUID().toString());
        EntityRefelectUtils.setFieldValue(object, <span class="hljs-string">"createdAt"</span>, LocalDateTime.now());
        EntityRefelectUtils.setFieldValue(object, <span
                    class="hljs-string">"updatedAt"</span>, LocalDateTime.now());<span class="hljs-comment">//在插入数据时自动更新id,createdAt,updatedAt</span>
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span
            class="hljs-title">beforeUpdate</span><span class="hljs-params">(E object)</span> </span>{
        EntityRefelectUtils.setFieldValue(object, <span
                    class="hljs-string">"updatedAt"</span>, LocalDateTime.now());<span class="hljs-comment">//在更新数据时自动更新updatedAt</span>
    }
}
</div></code></pre>
        <p>对应关系如下:</p>
        <p>count 参数表示执行成功的条数</p>
        <table>
            <thead>
            <tr>
                <th style="text-align:left">启用</th>
                <th style="text-align:left">需重写的方法</th>
                <th style="text-align:left">作用于</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td style="text-align:left">useBeforeInsert</td>
                <td style="text-align:left">beforeInsert(E entity)</td>
                <td style="text-align:left">insertSelective(..)/insert(..)执行插入之前</td>
            </tr>
            <tr>
                <td style="text-align:left">useAfterInsert</td>
                <td style="text-align:left">afterInsert(E entity,int count)</td>
                <td style="text-align:left">insertSelective(..)/insert(..)执行插入之后</td>
            </tr>
            <tr>
                <td style="text-align:left">useBeforeUpdate</td>
                <td style="text-align:left">beforeUpdate(E entity)</td>
                <td style="text-align:left">updateSelective(..)/update(..)执行更新之前</td>
            </tr>
            <tr>
                <td style="text-align:left">useAfterUpdate</td>
                <td style="text-align:left">afterUpdate(E entity,int count)</td>
                <td style="text-align:left">updateSelective(..)/update(..)/updateByColumn(..)执行更新之后</td>
            </tr>
            <tr>
                <td style="text-align:left">useBeforeDelete</td>
                <td style="text-align:left">beforeDelete(ID id)</td>
                <td style="text-align:left">deleteOneById(..)执行删除之前</td>
            </tr>
            <tr>
                <td style="text-align:left">useAfterDelete</td>
                <td style="text-align:left">void afterDelete(ID id,int count)</td>
                <td style="text-align:left">deleteOneById(..)执行删除之后</td>
            </tr>
            </tbody>
        </table>
        <h2 id="sqlbasedao">SQL构建器在BaseDAO中的使用</h2>
        <p>BaseDAO整合了SQL构建器，在继承BaseDAO的类中你可以你可以直接调用 <code>this.SELECT(..)/this.UPDATE(..) /this.DELETE(..)
            /this.INSERT(..)</code> , 注意：不用设置
            <strong>namedParameterJdbcTemplate</strong>或者<strong>dataSource</strong>
        </p>
        <pre class="hljs"><code><div><span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span
                    class="hljs-title">StudentDAO</span> <span class="hljs-keyword">extends</span> <span
                    class="hljs-title">ApplicationBaseDAO</span>&lt;<span
                    class="hljs-title">Student</span>, <span class="hljs-title">String</span>&gt; </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span
            class="hljs-title">queryListByName</span><span class="hljs-params">()</span> </span>{
        List&lt;Student&gt; list = <span class="hljs-keyword">this</span>.getSQL().SELECT(<span
                    class="hljs-string">"*"</span>).FROM(<span class="hljs-keyword">this</span>.tableName)
                                        .WHERE(<span class="hljs-string">"name"</span>).LIKE(<span class="hljs-string">"'李%'"</span>)
                                        .queryList(Student.class);<span class="hljs-comment">//查询列表</span>
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span
            class="hljs-title">updateById</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>.getSQL().UPDATE(<span
                    class="hljs-keyword">this</span>.tableName).SET(<span class="hljs-string">"name"</span>,<span
                    class="hljs-string">"Jakk"</span>).WHERE(<span class="hljs-string">"id"</span>).eq(<span
                    class="hljs-string">"123"</span>).update();
    }
}
</div></code></pre>
        <h1 id="7">7. 通用工具</h1>
        <h2 id="sqlin">获取sql的IN列表</h2>
        <p><code>FastSQLUtils.getInClause(Collection&lt;?&gt; collection)</code>,会根据Collection的类型自动判断使用什么样的分隔符:</p>
        <pre class="hljs"><code><div>FastSQLUtils.getInClause(Lists.newArrayList(<span
                class="hljs-number">1</span>, <span
                class="hljs-number">23</span>, <span class="hljs-number">4</span>, <span
                class="hljs-number">15</span>))  <span
                class="hljs-comment">//生成=&gt;(1,23,4,15)</span>
FastSQLUtils.getInClause(Lists.newArrayList(<span class="hljs-string">"dog"</span>, <span
                    class="hljs-string">"people"</span>, <span class="hljs-string">"food"</span>, <span
                    class="hljs-string">"apple"</span>)) <span
                    class="hljs-comment">//生成=&gt; ('dog','people','food','apple')</span>
</div></code></pre>
        <p>说明：IN功能已经整合到SQL构建器的IN方法</p>
        <h2 id="like">获取LIKE通配符</h2>
        <pre class="hljs">
FastSqlUtils.bothWildcard("李"); //%李%
FastSqlUtils.leftWildcard("李"); //%李
FastSqlUtils.rightWildcard("李");//李%
        </pre>
        <h1 id="8">8. 配置项</h1>
        <p>显示sql日志,需要调节相应的类日志级别：
            org.springframework.jdbc.core.JdbcTemplate 日志级别调整为 debug 会显示SQL语句
            org.springframework.jdbc.core.StatementCreatorUtils 日志级别调整为 trace 会显示绑定参数过程</p>
        <p>下面是Springboot中的配置：</p>
        <pre><code class="language-properties">#显示sql
logging.level.org.springframework.jdbc.core.JdbcTemplate=debug
#显示绑定的参数
logging.level.org.springframework.jdbc.core.StatementCreatorUtils=trace
</code></pre>
    </div>

</div>
</body>
</html>